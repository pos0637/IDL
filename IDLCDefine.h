
#ifndef __IDLC_DEFINE_H__
#define __IDLC_DEFINE_H__

namespace IDLC {
    enum _IDLFlag {
        IDL_NOP = 0x00,
        IDL_LANG_CPP = 0x01,
        IDL_LANG_CS = 0x02,
        IDL_LANG_JAVA = 0x04,
        IDL_LANG_OBJC = 0x08,
        IDL_SERIALIZE = 0x10,
        IDL_PRINT_TREE = 0x20,
        IDL_MODE_MODELS = 0x40,
        IDL_MODE_IPC = 0x80,
        IDL_VAR_TYPE_CPP = 0x1000,
        IDL_VAR_TYPE_OBJC = 0x2000,
        IDL_VAR_TYPE_CS = 0x4000,
        IDL_VAR_TYPE_JAVA = 0x8000,
        IDL_VAR_TYPE_DECLARE = 0x10000,
        IDL_VAR_TYPE_NOMODIFY = 0x20000,
        IDL_VAR_TYPE_PROPERTY = 0x40000,
        IDL_VAR_TYPE_FORM_PARAMETER = 0x80000,
        IDL_GENERATE_INCLUDE_FILE = 0x100000,
        IDL_LANG_JAVASCRIPT = 0x200000,
        IDL_LANG_ES6 = 0x400000
    };

    enum SymbolType {
        SymbolType_Begin,
        SymbolType_End,
        SymbolType_Stmt,
        SymbolType_FileBegin,
        SymbolType_FileEnd,
        SymbolType_UsingList,
        SymbolType_Using,
        SymbolType_NameSpace,
        SymbolType_Class,
        SymbolType_BaseClass,
        SymbolType_Interface,
        SymbolType_Multiple,
        SymbolType_Singleton,
        SymbolType_Function,
        SymbolType_FunctionName,
        SymbolType_Construction,
        SymbolType_ParameterList,
        SymbolType_Parameter,
        SymbolType_ReturnType,
        SymbolType_Serialize,
        SymbolType_Unserialize,
        SymbolType_Enum,
        SymbolType_Member,
        SymbolType_TypeReference,
        SymbolType_VarId,
        SymbolType_Int8,
        SymbolType_Byte,
        SymbolType_Int16,
        SymbolType_Int32,
        SymbolType_Int64,
        SymbolType_UInt8,
        SymbolType_UInt16,
        SymbolType_UInt32,
        SymbolType_UInt64,
        SymbolType_Float,
        SymbolType_Double,
        SymbolType_Boolean,
        SymbolType_Int8_NULL,
        SymbolType_Byte_NULL,
        SymbolType_Int16_NULL,
        SymbolType_Int32_NULL,
        SymbolType_Int64_NULL,
        SymbolType_UInt8_NULL,
        SymbolType_UInt16_NULL,
        SymbolType_UInt32_NULL,
        SymbolType_UInt64_NULL,
        SymbolType_Float_NULL,
        SymbolType_Double_NULL,
        SymbolType_Boolean_NULL,
        SymbolType_ByteArray,
        SymbolType_String,
        SymbolType_List,
        SymbolType_Void,
        SymbolType_Semicolon,
        SymbolType_OpenAngleBracket,
        SymbolType_CloseAngleBracket,
        SymbolType_LBrace,
        SymbolType_RBrace,
        SymbolType_LParenthese,
        SymbolType_RParenthese,
        SymbolType_Comma,
        SymbolType_Colon,
        SymbolType_COMMENT1,
        SymbolType_COMMENT2,
        SymbolType_LeftSquareBracket,
        SymbolType_RightSquareBracket,
        SymbolType_ArrayLength
    };

    static const wchar_t * sSymbolNameList[] = {
        L"Begin",
        L"End",
        L"Stmt",
        L"FileBegin",
        L"FileEnd",
        L"UsingList",
        L"Using",
        L"NameSpace",
        L"Class",
        L"BaseClass",
        L"Interface",
        L"Multiple",
        L"Singleton",
        L"Function",
        L"FunctionName",
        L"Construction",
        L"ParameterList",
        L"Parameter",
        L"ReturnType",
        L"Serialize",
        L"Unserialize",
        L"Enum",
        L"Member",
        L"TypeReference",
        L"VarId",
        L"Int8",
        L"Byte",
        L"Int16",
        L"Int32",
        L"Int64",
        L"UInt8",
        L"UInt16",
        L"UInt32",
        L"UInt64",
        L"Float",
        L"Double",
        L"Boolean",
        L"Int8_NULL",
        L"Byte_NULL",
        L"Int16_NULL",
        L"Int32_NULL",
        L"Int64_NULL",
        L"UInt8_NULL",
        L"UInt16_NULL",
        L"UInt32_NULL",
        L"UInt64_NULL",
        L"Float_NULL",
        L"Double_NULL",
        L"Boolean_NULL",
        L"ByteArray",
        L"String",
        L"List",
        L"Void",
        L"Semicolon",
        L"OpenAngleBracket",
        L"CloseAngleBracket",
        L"LBrace",
        L"RBrace",
        L"LParenthese",
        L"RParenthese",
        L"Comma",
        L"Colon",
        L"COMMENT1",
        L"COMMENT2",
        L"LeftSquareBracket",
        L"RightSquareBracket",
        L"ArrayLength"
    };

    static const wchar_t * sDataTypeMappingToCpp[] = {
        L"AXP::Int8",
        L"AXP::Int8",
        L"AXP::Int16",
        L"AXP::Int32",
        L"AXP::Int64",
        L"AXP::UInt8",
        L"AXP::UInt16",
        L"AXP::UInt32",
        L"AXP::UInt64",
        L"AXP::Float",
        L"AXP::Double",
        L"AXP::Boolean",
        L"AXP::Int8$",
        L"AXP::Int8$",
        L"AXP::Int16$",
        L"AXP::Int32$",
        L"AXP::Int64$",
        L"AXP::UInt8$",
        L"AXP::UInt16$",
        L"AXP::UInt32$",
        L"AXP::UInt64$",
        L"AXP::Float$",
        L"AXP::Double$",
        L"AXP::Boolean$",
        L"AXP::Sp<AXP::ByteArray>",
        L"AXP::Sp<AXP::String>",
        L"AXP::List",
        L"AXP::Void",
    };

    static const wchar_t * sDataTypeMappingToCs[] = {
        L"SByte",
        L"SByte",
        L"Int16",
        L"Int32",
        L"Int64",
        L"Byte",
        L"UInt16",
        L"UInt32",
        L"UInt64",
        L"Single",
        L"Double",
        L"Boolean",
        L"SByte?",
        L"SByte?",
        L"Int16?",
        L"Int32?",
        L"Int64?",
        L"Byte?",
        L"UInt16?",
        L"UInt32?",
        L"UInt64?",
        L"Single?",
        L"Double?",
        L"Boolean?",
        L"Byte[]",
        L"String",
        L"List",
        L"void",
    };

    static const wchar_t * sDataTypeMappingToJava[] = {
        L"byte",
        L"byte",
        L"short",
        L"int",
        L"long",
        L"short",
        L"int",
        L"long",
        L"BigInteger",
        L"float",
        L"double",
        L"boolean",
        L"Byte",
        L"Byte",
        L"Short",
        L"Integer",
        L"Long",
        L"Short",
        L"Integer",
        L"Long",
        L"BigInteger",
        L"Float",
        L"Double",
        L"Boolean",
        L"byte[]",
        L"String",
        L"List",
        L"void",
    };

    static const wchar_t * sDataTypeMappingToObjC[] = {
        L"int8_t",
        L"int8_t",
        L"int16_t",
        L"int32_t",
        L"int64_t",
        L"uint8_t",
        L"uint16_t",
        L"uint32_t",
        L"uint64_t",
        L"float_t",
        L"double_t",
        L"Boolean",
        L"NSNumber *",
        L"NSNumber *",
        L"NSNumber *",
        L"NSNumber *",
        L"NSNumber *",
        L"NSNumber *",
        L"NSNumber *",
        L"NSNumber *",
        L"NSNumber *",
        L"NSNumber *",
        L"NSNumber *",
        L"NSNumber *",
        L"NSData *",
        L"NSString *",
        L"NSMutableArray *",
        L"void",
    };

#define WRITE_STRING_TO_FILE(...) \
    do { \
        Sp<String> str = String::Create(__VA_ARGS__); \
        if (str == NULL) \
            return; \
        Sp<ByteArray> byteArray = str->GetBytes(); \
        if (byteArray == NULL)   \
            return;             \
        if (::fwrite(byteArray->GetPayload(), byteArray->GetUsed() - 1, 1, file) != 1) \
            return; \
    } while(0)

#ifdef  FWRITE
#undef FWRITE
#endif
#define FWRITE(str) \
    do { \
        if (::fwrite(str, Strlen(str), 1, file) != 1) \
            return; \
    }while(0)

#define DEBUG_PRINT(...) \
    do { \
        Sp<String> str = String::Create(__VA_ARGS__); \
        if (str == NULL) \
            break; \
        printf("error: %s, %d, %ls \n", __FUNCTION__, __LINE__, (PCWStr)*str); \
    } while(0)
} // namespace IDLC

#endif // __IDLC_DEFINE_H__
